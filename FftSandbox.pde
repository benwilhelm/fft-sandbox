/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  * <p>
  * For more information about Minim and additional features, 
  * visit http://code.compartmental.net/minim/
  */

import processing.serial.*;
import ddf.minim.analysis.*;
import ddf.minim.*;
import cc.arduino.*;

Minim       minim;
//AudioInput  audio;
AudioPlayer audio;
FFT         fft;
Arduino     arduino;


/**********************
/* DEFINE COLOR PINS */
final int RED   =  9;
final int GREEN = 10;
final int BLUE  = 11;
final int[] PINS = {BLUE, RED, GREEN};

final String AUDIO_FILE = "10-Whispers-2.mp3";

final int BAND_MIN = 1;
final int BAND_MAX = 200;
final int BAND_DIFF = BAND_MAX - BAND_MIN;
final int NUM_CHANNELS = 3;
final int CHANNEL_WIDTH = ceil(BAND_DIFF / NUM_CHANNELS);

int intensity_multiplier = 6;
int intensity_shift = -10;
float[][] channels = new float[NUM_CHANNELS][CHANNEL_WIDTH];
float[] C_LEVELS = new float[3];


void setup()
{
  size(512, 256, P3D);
  
  minim = new Minim(this);
  arduino = new Arduino(this, Arduino.list()[1], 57600);
  //lineIn = minim.getLineIn();
  audio = minim.loadFile(AUDIO_FILE);
  audio.play();
  
  // create an FFT object that has a time-domain buffer 
  // the same size as jingle's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fft = new FFT( audio.bufferSize(), audio.sampleRate() );
  
  arduino.pinMode(RED,   arduino.OUTPUT);
  arduino.pinMode(GREEN, arduino.OUTPUT);
  arduino.pinMode(BLUE,  arduino.OUTPUT);

  // RGB LED is common anode, so the polarity is reversed.
  // High is low and low is high. We're actually turning 
  // all channels off here.
  arduino.digitalWrite(RED,   arduino.HIGH);
  arduino.digitalWrite(GREEN, arduino.HIGH);
  arduino.digitalWrite(BLUE,  arduino.HIGH);
}

boolean once = true;
void draw()
{
  background(0);
  stroke(128);
  textSize(18);
  // perform a forward FFT on the samples in jingle's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fft.forward( audio.mix );
  
  int next_band=0;
  for(int i = BAND_MIN; i < BAND_MAX; i++)
  {
    int channel = (int)floor( i / CHANNEL_WIDTH );
    int channel_band = (int)( i % CHANNEL_WIDTH );

    int this_band = (int) (i / ( Math.log(BAND_MAX - i) / Math.log(1.8) ));
    float intensity = channelIntensity(fft, this_band);
    if (this_band >= next_band) {
      next_band = (int) (i+1 / ( Math.log(BAND_MAX - i+1) / Math.log(1.8) ));
      
      for (int band=this_band; band<next_band; band++) {
        float next_intensity = channelIntensity(fft, next_band);
        intensity = max(intensity, next_intensity); 
      }
    }

    if (channel < channels.length){
      channels[channel][channel_band] = intensity;
    }
    
    line( i*2, height - 10, i*2, height - intensity+10 );
  }
  
  translate(0,0,-1);
  
  for (int c=0; c<channels.length; c++) {

    switch (c) {
      case 0:
        
        stroke(0,0,255);
        fill(0,0,255);
        break;
      
      case 1:
        stroke(255,0,0);
        fill(255,0,0);
        break;
      
      case 2:
        stroke(0,255,0);
        fill(0,255,0);
        break;
      
    }

    float c_intensity = max( channels[c] );

    rect( c*CHANNEL_WIDTH*2, height - c_intensity, CHANNEL_WIDTH*2, c_intensity) ;
    C_LEVELS[c] = c_intensity;
    
    int pin = PINS[c];
    int pin_intensity = (int) constrain((254 - c_intensity), 0, 250);
    fill(255);
    text(pin_intensity, c*CHANNEL_WIDTH*2+10, height-10);
    
    arduino.analogWrite(pin, pin_intensity);
  }
  
  translate(0,0,-1);
  stroke(128);
  fill(128);
  once = false;
}

float channelIntensity(FFT fft, int band) {
  float intensity = fft.getBand(band);
  intensity *= intensity_multiplier;
  intensity += intensity_shift;
  return constrain(intensity, 0, 255);
}

float average(float[] vals) {
  float sum = 0;
  for (int i=0; i<vals.length; i++) {
    sum += vals[i];
  }
  return sum / vals.length;
}


